console.log('位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。');
var i = 1234.56;
console.log(i = i | 0);

function toInt32(x) {
    return x | 0;
}

console.log(toInt32(1.001)); // 1
console.log(toInt32(1.999)); // 1
console.log(toInt32(1)); // 1
console.log(toInt32(-1)); // -1
console.log(toInt32(Math.pow(2, 32) + 1)); // 1
console.log(toInt32(Math.pow(2, 32) - 1)); // -1


console.log('二进制或运算符（|）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0。');
console.log(0 | 3);      // 3

console.log('位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。');
console.log(2.9 | 0); // 2
console.log(-2.9 | 0); // -2


console.log('需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。');
console.log(2147483649.4 | 0);


console.log('二进制与运算符（&）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1。');
console.log(0 & 3); // 0

console.log('二进制否运算符（~）将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。');
console.log(~ 3); // -1 - 3 = -4
console.log(~ -3);  // -1 - (-3) = 2
console.log('对一个整数连续两次二进制否运算，得到它自身。');
console.log(~~3); // 3


console.log('对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。');
// 相当于~Number('011')
console.log(~'011');  // -12

// 相当于~Number('42 cats')
console.log(~'42 cats'); // -1

// 相当于~Number('0xcafebabe')
console.log(~'0xcafebabe'); // 889275713


// 相当于~Number('deadbeef')
console.log(~'deadbeef'); // -1

console.log('对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。');
// 相当于 ~Number([])
console.log(~[]); // -1

// 相当于 ~Number(NaN)
console.log(~NaN); // -1

// 相当于 ~Number(null)
console.log(~null); // -1


console.log('异或运算（^）在两个二进制位不同时返回1，相同时返回0。');
console.log(0 ^ 3); // 3

console.log('“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。');
var a = 10;
var b = 99;

a ^= b, b ^= a, a ^= b;

console.log(a); // 99
console.log(b); // 10


console.log('异或运算也可以用来取整。');
console.log(12.9 ^ 0); // 12

console.log('左移运算符（<<）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。');
// 4 的二进制形式为100，
// 左移一位为1000（即十进制的8）
// 相当于乘以2的1次方
console.log(4 << 1);
// 8

console.log(-4 << 1);
// -8

console.log('如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。');
console.log(13.5 << 0);
// 13

console.log(-13.5 << 0);
// -13


console.log('左移运算符用于二进制数值非常方便。');
var color = {r: 186, g: 218, b: 85};

// RGB to HEX
// (1 << 24)的作用为保证结果是6位数
var rgb2hex = function(r, g, b) {
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
        .toString(16) // 先转成十六进制，然后返回字符串
        .substr(1);   // 去除字符串的最高位，返回后面六个字符串
}

console.log(rgb2hex(color.r, color.g, color.b));
// "#bada55"


console.log('右移运算符（>>）表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）。');
console.log(4 >> 1);
// 2
/*
// 因为4的二进制形式为 00000000000000000000000000000100，
// 右移一位得到 00000000000000000000000000000010，
// 即为十进制的2
*/

console.log(-4 >> 1);
// -2
/*
// 因为-4的二进制形式为 11111111111111111111111111111100，
// 右移一位，头部补1，得到 11111111111111111111111111111110,
// 即为十进制的-2
*/

console.log('右移运算可以模拟 2 的整除运算。');
console.log(5 >> 1);
// 2
// 相当于 5 / 2 = 2

console.log(21 >> 2);
// 5
// 相当于 21 / 4 = 5

console.log(21 >> 3);
// 2
// 相当于 21 / 8 = 2

console.log(21 >> 4);
// 1
// 相当于 21 / 16 = 1


console.log('带符号位的右移运算符（>>>）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（>>）完全一致，区别主要在于负数。');
console.log(4 >>> 1);
// 2

console.log(-4 >>> 1);
// 2147483646
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 带符号位的右移一位，得到01111111111111111111111111111110，
// 即为十进制的2147483646。
*/

console.log('这个运算实际上将一个值转为32位无符号整数。');
console.log(-1 >>> 0); // 4294967295


console.log('假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。');
var FLAG_A = 1; // 0001
var FLAG_B = 2; // 0010
var FLAG_C = 4; // 0100
var FLAG_D = 8; // 1000